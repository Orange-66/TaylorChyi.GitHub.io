<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java中为什么没有虚字段表来实现方法调用和字段访问的一致性？</title>
    <url>/2023/04/16/Java%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E8%99%9A%E5%AD%97%E6%AE%B5%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%92%8C%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #虚方法表 #字段访问 #设计原则</p>
<hr>
<blockquote>
<p>那为什么 Java 不设计一个虚字段表来实现方法调用和字段访问的结果一致呢</p>
</blockquote>
<p>虽然在某些情况下，实现一个虚字段表似乎能让方法调用和字段访问的行为保持一致，但这并不符合 Java 的设计原则。在 Java 中，方法和字段的作用和原理是有所不同的：</p>
<ol>
<li>方法是用于定义对象的行为的，它们可以被子类覆盖以实现不同的行为。这是多态的核心，它允许我们以统一的方式处理不同类型的对象。为了实现多态，Java引入了虚方法表，使得方法调用在运行时可以根据实际对象类型执行相应的方法。</li>
<li>另一方面，字段用于存储对象的状态。通常，我们希望字段在编译时就能确定，以避免意外地改变对象的状态。将字段设置为私有并通过方法（getter和setter）访问，是一种常见的封装实践，以确保字段访问的正确性和安全性。</li>
</ol>
<p>设计一个虚字段表可能会引入额外的复杂性，并使得字段访问的性能受到影响。在Java中，编译时字段访问和运行时方法调用的不同行为是有意为之，以确保代码的可读性、可维护性和执行效率。</p>
<p>总之，Java之所以没有引入虚字段表，是因为它违背了字段和方法的基本设计原则。在处理多态时，我们应该通过方法调用来实现多态行为，而不是直接访问字段。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>虚方法表</tag>
        <tag>字段访问</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中static、final和private方法为什么不是动态绑定</title>
    <url>/2023/04/16/Java%E4%B8%ADstatic%E3%80%81final%E5%92%8Cprivate%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #Java #静态方法 #final方法 #private方法 #动态绑定 #静态绑定</p>
<hr>
<p>在Java中，静态方法、final方法和private方法（隐式final）都不是动态绑定的，而是静态绑定的。以下是对这几种方法为什么不是动态绑定的解释：</p>
<ol>
<li> static方法：</li>
</ol>
<p>静态方法是类级别的方法，它们不依赖于具体的实例，而是与类本身相关。因此，当调用静态方法时，编译器可以在编译时确定要调用哪个类的静态方法。不需要等到运行时去查找实际的实现。所以，静态方法不需要动态绑定，而是采用静态绑定。</p>
<p>举例：假设我们有一个父类<code>Parent</code>和一个子类<code>Child</code>，它们都有一个静态方法<code>staticMethod</code>。当我们调用<code>Parent.staticMethod()</code>或<code>Child.staticMethod()</code>时，我们直接告诉编译器要调用哪个类的静态方法，不需要动态绑定。</p>
<ol start="2">
<li> final方法：</li>
</ol>
<p>final方法是不允许被子类重写的方法。这意味着，当调用一个final方法时，编译器可以确保在编译时确定要调用的具体实现，而无需等到运行时去查找。因此，final方法也采用静态绑定。</p>
<p>举例：假设我们有一个父类<code>Parent</code>，其中有一个final方法<code>finalMethod</code>。如果有一个子类<code>Child</code>继承自<code>Parent</code>，那么<code>Child</code>不能重写<code>finalMethod</code>。因此，当我们调用<code>Parent.finalMethod()</code>或<code>Child.finalMethod()</code>时，编译器已经知道要调用的是<code>Parent</code>类的<code>finalMethod</code>，无需动态绑定。</p>
<ol start="3">
<li> private方法（隐式final）：</li>
</ol>
<p>private方法是类的私有方法，它们不能被子类访问或重写。实际上，它们对子类是不可见的。因此，当调用一个private方法时，编译器可以在编译时确定要调用的具体实现。这使得private方法也采用静态绑定。</p>
<p>举例：假设我们有一个类<code>MyClass</code>，其中有一个private方法<code>privateMethod</code>。当我们调用<code>MyClass.privateMethod()</code>时，编译器已经知道要调用的是<code>MyClass</code>的<code>privateMethod</code>，无需动态绑定。</p>
<p>综上所述，由于静态方法、final方法和private方法在编译时就可以确定具体的实现，它们不需要动态绑定，而是采用静态绑定。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>静态方法</tag>
        <tag>final方法</tag>
        <tag>private方法</tag>
        <tag>动态绑定</tag>
        <tag>静态绑定</tag>
      </tags>
  </entry>
  <entry>
    <title>is-like-a关系中向上转型的示例</title>
    <url>/2023/04/16/is-like-a%E5%85%B3%E7%B3%BB%E4%B8%AD%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E7%9A%84%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #向上转型 #is-like-a关系 </p>
<hr>
<p>假设我们有一个基类 Animal 和两个子类 Dog 和 Bird。其中，Dog 类扩展了 Animal 类并添加了一个新方法 <code>bark()</code>，Bird 类也扩展了 Animal 类并添加了一个新方法 <code>fly()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设我们有一个方法 <code>makeAnimalEat</code>，这个方法接受一个 Animal 对象，并调用它的 <code>eat()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeAnimalEat</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">    animal.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，我们不关心传入对象的具体类型，只要它是 Animal 或其子类即可。现在，我们可以创建 Dog 和 Bird 对象，并将它们向上转型为 Animal 类型，传递给 <code>makeAnimalEat</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">Bird bird = <span class="keyword">new</span> Bird();</span><br><span class="line"></span><br><span class="line">makeAnimalEat(dog); <span class="comment">// 向上转型为Animal</span></span><br><span class="line">makeAnimalEat(bird); <span class="comment">// 向上转型为Animal</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，向上转型允许我们将Dog和Bird对象视为Animal对象，并通过<code>makeAnimalEat</code>方法调用它们的<code>eat()</code>方法。然而，这也意味着我们不能在<code>makeAnimalEat</code>方法中直接调用Dog的<code>bark()</code>方法或Bird的<code>fly()</code>方法，因为这些方法不属于Animal类的接口。</p>
<p>在某些情况下，我们可能需要在 <code>makeAnimalEat</code> 方法中根据传入对象的确切类型执行一些特定操作。例如，我们希望让 Dog 在吃东西之前先叫一下。为了实现这个功能，我们需要重新确定对象的类型，然后调用相应的扩展方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeAnimalEat</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">        ((Dog) animal).bark();</span><br><span class="line">    &#125;</span><br><span class="line">    animal.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用<code>instanceof</code>操作符检查对象是否为Dog类型，如果是，则向下转型并调用<code>bark()</code>方法。注意，这种类型检查和向下转型的操作会降低代码的灵活性，并可能导致不易维护的代码。但在某些情况下，这种方法可能是必要的。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>向上转型</tag>
        <tag>is-like-a关系</tag>
      </tags>
  </entry>
  <entry>
    <title>一条通用准则</title>
    <url>/2023/04/16/%E4%B8%80%E6%9D%A1%E9%80%9A%E7%94%A8%E5%87%86%E5%88%99/</url>
    <content><![CDATA[<p>使用继承表达行为的差异，使用属性表达状态的变化。</p>
]]></content>
  </entry>
  <entry>
    <title>为什么不使用接口实现eat方法</title>
    <url>/2023/04/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0eat%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #继承 #接口 </p>
<hr>
<p>在某些情况下，使用接口确实是一个更好的选择，尤其是当我们希望保证类遵循某个特定的约定（比如具有 <code>eat()</code> 方法）时。如果我们认为 Animal 类不需要包含任何默认实现或共享状态（属性），那么使用接口可能是一个更合适的选择。</p>
<p>以下是一个使用接口的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用接口的好处是它可以让我们保证所有实现了 Eatable 接口的类都必须提供 <code>eat()</code> 方法的实现。这使得我们可以在需要 Eatable 对象时，确保它们都具有该方法。</p>
<p>然而，使用接口并不总是更好。在某些情况下，使用继承可能更适合。例如，如果Animal类包含一些共享的状态（属性）和方法实现，那么使用继承将使我们能够更轻松地在子类中复用这些共享代码。此外，我们还可以利用继承在子类中覆盖基类方法，以提供更具体的实现。</p>
<p>总之，在确定是否使用接口或继承时，需要考虑类之间的关系、代码重用、以及预期的扩展性。根据具体情况，我们可能会选择实现接口，或者继承一个基类，或者同时使用这两种方法。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>继承</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么构造器中的动态绑定方法绑定了子类方法</title>
    <url>/2023/04/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E7%BB%91%E5%AE%9A%E4%BA%86%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #构造器 #动态绑定 </p>
<hr>
<p>在 Java 中，除了 <code>static</code> 和 <code>final</code> 方法（<code>private</code> 方法也是隐式的 <code>final</code>）以外，其他所有方法都是后期绑定，即动态绑定。这意味着在编译时并不确定要调用哪个方法，而是在运行时根据对象的实际类型来确定要调用哪个方法。</p>
<p>在你提供的示例中，<code>Base</code> 类的构造器中调用了 <code>show()</code> 方法。当我们创建一个 <code>Derived</code> 类的实例时，它首先会调用父类 <code>Base</code> 的构造器。此时，虽然是在父类构造器中调用 <code>show()</code> 方法，但实际创建的对象是 <code>Derived</code> 类型。由于 <code>show()</code> 方法是动态绑定的，因此在运行时，Java 会根据对象的实际类型（<code>Derived</code> 类型）来确定调用哪个方法。因此，此时调用的是 <code>Derived</code> 类中重写的 <code>show()</code> 方法，而不是 <code>Base</code> 类中的 <code>show()</code> 方法。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>动态绑定</tag>
        <tag>构造器</tag>
      </tags>
  </entry>
  <entry>
    <title>使用继承复用共享代码的例子</title>
    <url>/2023/04/16/%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF%E5%A4%8D%E7%94%A8%E5%85%B1%E4%BA%AB%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #继承 #代码复用</p>
<hr>
<p>以下是一个使用继承来复用共享代码的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is sleeping.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Animal</code> 类有两个属性 <code>name</code> 和 <code>age</code>，以及一些共享的方法 <code>eat()</code>、<code>sleep()</code>、<code>getName()</code> 和 <code>getAge()</code>。通过继承 <code>Animal</code> 类，我们可以在 <code>Dog</code> 和 <code>Bird</code> 子类中复用这些共享的代码。</p>
<p>注意，在子类中我们使用<code>super()</code>调用来调用父类的构造方法，这样我们就可以在子类中设置<code>name</code>和<code>age</code>属性。另外，我们可以通过<code>getName()</code>和<code>getAge()</code>方法访问这些属性，从而在子类中实现自定义行为，如<code>bark()</code>和<code>fly()</code>方法。</p>
<p>继承使我们能够在不修改<code>Animal</code>类的情况下轻松地为<code>Dog</code>和<code>Bird</code>类添加新功能，同时保持共享代码的一致性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
        <tag>代码复用</tag>
      </tags>
  </entry>
  <entry>
    <title>在选择接口实现和继承关系时的考虑因素</title>
    <url>/2023/04/16/%E5%9C%A8%E9%80%89%E6%8B%A9%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E6%97%B6%E7%9A%84%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #接口 #继承 #设计原则 </p>
<hr>
<blockquote>
<p>所以我们可以说，在选用接口实现还是继承关系上，我们可以通过判断到底是各各类之之间只是行为上相似，还是在不仅仅行为上、状态上也有信息需要共享，是这样么？希望更正或补充，如果表述上有欠缺的。</p>
</blockquote>
<p>是的，您的理解是正确的。在选择使用接口实现还是继承关系时，我们需要根据类之间的关系来判断。以下是一些关键点，可以帮助您决定使用哪种方式：</p>
<ol>
<li>如果类之间存在共享的状态（属性）和行为（方法实现），那么使用继承关系可能更合适。这样可以通过父类来复用这些共享代码，同时保持代码的一致性。</li>
<li>如果类之间仅仅在行为上相似，但没有共享的状态或方法实现，那么使用接口实现更合适。接口可以定义一组共享的行为，强制实现类遵循这些行为，但不强制它们共享任何状态或方法实现。</li>
<li>另外，还要考虑”单一职责原则”和”开闭原则”等设计原则。遵循这些原则可以帮助您创建更加灵活、易于维护的代码。</li>
</ol>
<p>总之，在选择使用接口实现还是继承关系时，关键是了解类之间的关系，以及它们之间需要共享的信息。您可以根据这些信息来决定使用哪种方式，以满足代码的复用、扩展和维护需求。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>设计原则</tag>
        <tag>继承</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>多态、接口与抽象类的关系与意义</title>
    <url>/2023/04/16/%E5%A4%9A%E6%80%81%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #接口 #抽象类 #设计</p>
<hr>
<blockquote>
<p>当我们已经有多态这一机制了之后，为什么还有 implements 这一设计呢？直接设计一个最上层的父类然后设计很多需要子类实现的抽象方法不就好了么？如果这样的方式不是多态的目的，那么抽象方法本身存在的意义又是什么呢？能否同时举例说明上述问题？</p>
</blockquote>
<p>多态是一种编程范式，它允许我们使用一个通用的接口引用不同类型的对象，并在运行时动态调用相应的方法。接口和抽象类都是实现多态的方式，但它们有不同的用途和特点。</p>
<ol>
<li> 接口（implements）：</li>
</ol>
<p>接口定义了一组规范，强调了类实现的“能做什么”。接口可以被多个类实现，这样可以实现多重继承的效果。当一个类实现了一个接口时，它承诺实现接口中定义的所有方法。这对于定义一些通用的行为和功能非常有用。接口还允许我们将实现和使用分离，使代码更加灵活和易于维护。</p>
<ol start="2">
<li> 抽象类（extends）：</li>
</ol>
<p>抽象类是一个特殊的类，它不能被实例化，只能被继承。抽象类中可以包含抽象方法和非抽象方法。抽象方法没有具体的实现，需要子类去实现。抽象类强调类之间的“是什么”关系，即子类“是一种”父类。抽象类适用于在类之间共享部分实现的情况。</p>
<p>以下是一个举例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口：表示可飞行的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类：表示鸟类，包含共享的属性和方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类：鹦鹉，继承自Bird类，实现Flyable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parrot</span> <span class="keyword">extends</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parrot</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parrot is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parrot is singing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个 <code>Flyable</code> 接口和一个 <code>Bird</code> 抽象类。<code>Parrot</code> 类继承了 <code>Bird</code> 类，并实现了 <code>Flyable</code> 接口。这样，我们可以使用多态的特性，将 <code>Parrot</code> 类的对象赋值给 <code>Bird</code> 类型或 <code>Flyable</code> 类型的引用，并在运行时动态调用相应的方法。</p>
<p>总之，接口和抽象类都是实现多态的方式，但它们有不同的目的和使用场景。接口强调行为和功能，适用于定义通用的规范；抽象类强调类之间的关系，适用于在类之间共享部分实现。在实际的软件设计中，我们通常根据需求选择合适的方式来实现多态。</p>
<p>对于你提到的“为什么还有implements这一设计”的问题，这是因为Java不支持多重继承，即一个类不能继承多个父类。通过接口，我们可以实现类似多重继承的效果。接口允许我们定义一组行为，并可以被多个类实现，使得代码更加灵活和模块化。</p>
<p>关于抽象方法的存在意义，抽象方法强制子类去实现某些特定的行为。当我们定义一个抽象类时，我们可以预见到子类需要实现某些共同的行为，但这些行为的具体实现可能因子类而异。通过抽象方法，我们可以确保所有的子类都会实现这些行为，而不需要在每个子类中重复编写相同的代码。</p>
<p>例如，在上述的例子中，<code>Bird</code> 抽象类中的 <code>sing</code> 方法是一个抽象方法。这表示所有继承自 <code>Bird</code> 的子类都必须实现 <code>sing</code> 方法，以确保它们都具有唱歌的行为。这样，我们可以在处理 <code>Bird</code> 类型的对象时，确保它们都可以调用 <code>sing</code> 方法，而不需要关心具体的实现细节。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>接口</tag>
        <tag>抽象类</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>多态的实现机制</title>
    <url>/2023/04/16/%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #实现机制 #示例 </p>
<blockquote>
<p>一旦学会了多态，就可以以多态的思维方式考虑每件事。然而，只有普通的方法调用可以是多态的。例如，如果你直接访问一个属性，该访问会在编译时解析： </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/FieldAccess.java </span></span><br><span class="line"><span class="comment">// Direct field access is determined at compile time </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">0</span>; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> field; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">1</span>; </span><br><span class="line">	<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> field; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSuperField</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.field; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldAccess</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		Super sup = <span class="keyword">new</span> Sub(); </span><br><span class="line">		<span class="comment">// Upcast </span></span><br><span class="line">		System.out.println(<span class="string">&quot;sup.field = &quot;</span> + sup.field + <span class="string">&quot;, sup.getField() = &quot;</span> + sup.getField()); </span><br><span class="line">		Sub sub = <span class="keyword">new</span> Sub(); </span><br><span class="line">		System.out.println(<span class="string">&quot;sub.field = &quot;</span> + sub.field + <span class="string">&quot;, sub.getField() = &quot;</span> + sub.getField() + <span class="string">&quot;, sub.getSuperField() = &quot;</span> + sub.getSuperField()) </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出： sup.field = 0, sup.getField() = 1 sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0 </span></span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>我注意到上述的代码中 sup.field = 0, sup.getField() = 1，这样我对于 Java 底层实现多态的机制有些迷惑，他是如何确定到底是哪个方法要被执行的呢，是否是有个存储方法的栈之类的呢？</p>
</blockquote>
<p>在 Java 中，多态仅适用于方法调用，而不适用于字段访问。这就是为什么在上面的例子中，<code>sup.field</code> 的值为0，而 <code>sup.getField()</code> 的值为1。字段的访问在编译时就已经确定，而方法调用则在运行时动态绑定。</p>
<p>在这个例子中，当我们执行以下语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Super sup = <span class="keyword">new</span> Sub(); <span class="comment">// Upcast</span></span><br></pre></td></tr></table></figure>
<p><code>sup</code> 是一个 <code>Super</code> 类型的引用，但它实际上引用了一个 <code>Sub</code> 类型的对象。当我们访问字段 <code>sup.field</code> 时，编译器在编译时就已经确定我们访问的是 <code>Super</code> 类型的 <code>field</code>，因此返回值为0。</p>
<p>然而，当我们调用 <code>sup.getField()</code> 时，JVM会在运行时检查<code>sup</code>引用的实际对象类型（即 <code>Sub</code> 类型），并调用 <code>Sub</code> 类中的 <code>getField()</code> 方法。这就是为什么 <code>sup.getField()</code> 返回1的原因。</p>
<p>多态背后的原理是利用了一种称为“虚方法表”（vtable）的机制。简而言之，当一个类被加载时，JVM会为其创建一个包含其所有方法的表。对于继承自父类的方法，子类中若有重写的方法，虚方法表中的对应条目将被子类方法替换。当我们通过一个引用调用一个方法时，JVM会根据引用的实际对象类型查找对应的虚方法表，然后调用表中对应的方法。</p>
<p>这就是Java实现多态的基本机制。要注意的是，多态仅适用于方法调用，不适用于字段访问。因此，在处理多态时，需要确保只通过方法调用来实现多态行为。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>实现机制</tag>
        <tag>示例</tag>
      </tags>
  </entry>
  <entry>
    <title>开闭原则</title>
    <url>/2023/04/16/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #设计原则 #开闭原则 #面向对象设计</p>
<hr>
<p>开闭原则（Open-Closed Principle，OCP）是面向对象设计和编程中的一种重要设计原则。该原则的核心思想是：</p>
<p>软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着在设计软件时，应当允许在不修改现有代码的情况下，添加新功能或者行为。</p>
<p>开闭原则的主要优点是提高了软件系统的可维护性和可复用性。遵循开闭原则可以使软件更容易适应变化，因为在添加新功能时，不需要对现有代码进行大量修改。这减少了引入新错误的风险，同时降低了维护成本。</p>
<p>为了实现开闭原则，通常需要使用以下技术和设计模式：</p>
<ol>
<li>抽象和封装：通过定义抽象类或接口，将可变的部分与不可变的部分分离，使得在不修改现有代码的情况下，可以通过继承或实现接口来扩展功能。</li>
<li>组合和聚合：通过将不同的功能模块组合在一起，可以在不修改现有代码的情况下，为系统添加新功能。</li>
<li>使用设计模式：很多设计模式，如策略模式、模板方法模式、装饰器模式等，都可以帮助实现开闭原则。</li>
</ol>
<p>当然，实际应用中，完全遵循开闭原则可能是非常困难的。然而，作为一种理念，开闭原则提醒我们在设计软件时要关注可维护性和可扩展性，尽量降低对现有代码的修改。</p>
]]></content>
      <tags>
        <tag>设计原则</tag>
        <tag>开闭原则</tag>
        <tag>面向对象设计</tag>
      </tags>
  </entry>
  <entry>
    <title>多态与接口的实际生产案例</title>
    <url>/2023/04/16/%E5%A4%9A%E6%80%81%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E9%99%85%E7%94%9F%E4%BA%A7%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #Java #多态 #接口 #实例</p>
<p>以下是一个简化的网球场地预约系统的例子，以展示多态和接口在实际生产中的应用。</p>
<p>首先，我们定义一个接口 <code>PaymentMethod</code>，表示不同的支付方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processPayment</span><span class="params">(<span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们为不同的支付方式创建实现类，例如 <code>CreditCard</code> 和 <code>PayPal</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> <span class="keyword">implements</span> <span class="title">PaymentMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processPayment</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Processing credit card payment: $&quot;</span> + amount);</span><br><span class="line">        <span class="comment">// 实际的信用卡支付处理逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayPal</span> <span class="keyword">implements</span> <span class="title">PaymentMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processPayment</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Processing PayPal payment: $&quot;</span> + amount);</span><br><span class="line">        <span class="comment">// 实际的PayPal支付处理逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们有一个 <code>Booking</code> 类，表示预约。这个类可以接受一个 <code>PaymentMethod</code> 类型的对象，以便在完成预约时处理支付：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Booking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentMethod paymentMethod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Booking</span><span class="params">(PaymentMethod paymentMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.paymentMethod = paymentMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeBooking</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Completing booking...&quot;</span>);</span><br><span class="line">        paymentMethod.processPayment(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用了接口和多态的概念。<code>PaymentMethod</code> 接口定义了一个规范，而 <code>CreditCard</code> 和 <code>PayPal</code> 类提供了具体的实现。这样，我们可以灵活地为 <code>Booking</code> 类添加新的支付方式，而不需要修改 <code>Booking</code> 类的代码。多态使得我们可以将不同支付方式的实现类对象赋值给 <code>PaymentMethod</code> 类型的引用，从而在运行时动态调用正确的方法。</p>
<p>在实际生产中，我们可以利用这种设计更轻松地添加新的支付方式，例如 <code>Alipay</code>、<code>WeChatPay</code> 等，只需要创建新的实现类并实现 <code>PaymentMethod</code> 接口即可。</p>
<p>以下是一个简单的测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PaymentMethod creditCard = <span class="keyword">new</span> CreditCard();</span><br><span class="line">        PaymentMethod payPal = <span class="keyword">new</span> PayPal();</span><br><span class="line"></span><br><span class="line">        Booking booking1 = <span class="keyword">new</span> Booking(creditCard);</span><br><span class="line">        Booking booking2 = <span class="keyword">new</span> Booking(payPal);</span><br><span class="line"></span><br><span class="line">        booking1.completeBooking(<span class="number">100</span>);</span><br><span class="line">        booking2.completeBooking(<span class="number">150</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个例子，我们可以看到多态和接口在实际生产中的应用，以及它们是如何提高代码的灵活性和可扩展性的。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>接口</tag>
        <tag>实例</tag>
      </tags>
  </entry>
  <entry>
    <title>构造器中调用动态绑定方法的隐患</title>
    <url>/2023/04/16/%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E8%B0%83%E7%94%A8%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E7%9A%84%E9%9A%90%E6%82%A3/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #构造器 #动态绑定 #隐蔽的bug</p>
<hr>
<blockquote>
<p>如果在构造器中调用了动态绑定方法，就会用到那个方法的重写定义。然而，调用的结果难以预料因为被重写的方法在对象被完全构造出来之前已经被调用，这使得一些 bug 很隐蔽，难以发现。<br>———<br>为什么调用结果是难以预料的，举例解释下？ 为什么这些 bug 就是隐蔽的了呢？</p>
</blockquote>
<p>调用构造器中动态绑定方法的结果难以预料，是因为在对象完全构造出来之前，重写的方法就已经被调用。这可能导致不完全初始化的对象状态或数据。我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        show(); <span class="comment">// 动态绑定方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived show, value: &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Derived derived = <span class="keyword">new</span> Derived();</span><br><span class="line">        derived.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Derived show, value: 0</span><br><span class="line">Derived show, value: 10</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Derived</code> 类继承了 <code>Base</code> 类，并重写了 <code>show()</code> 方法。当我们创建一个 <code>Derived</code> 类的实例时，会先调用父类 <code>Base</code> 的构造器。在 <code>Base</code> 构造器中，调用了动态绑定方法 <code>show()</code>，此时会调用 <code>Derived</code> 类中重写的 <code>show()</code> 方法。然而，此时 <code>Derived</code> 类的构造器尚未执行，<code>value</code> 字段还没有被初始化为 10，所以输出的 <code>value</code> 值是 0。这就是为什么调用结果难以预料。</p>
<p>这些bug隐蔽的原因是，程序员可能没有意识到在构造器中调用动态绑定方法会导致这样的问题，而且问题表现为数据不一致，这使得在调试时难以发现问题的根源。因此，在构造器中调用动态绑定方法可能导致难以追踪和定位的bug。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>动态绑定</tag>
        <tag>构造器</tag>
        <tag>隐蔽的bug</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象和封装示例</title>
    <url>/2023/04/16/%E6%8A%BD%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #抽象 #封装 #面向对象设计 #开闭原则 </p>
<hr>
<p>以下是一个关于图形绘制的例子，展示了如何使用抽象和封装实现开闭原则：</p>
<p>首先，我们创建一个抽象类<code>Shape</code>，定义了一个抽象方法<code>draw()</code>，用于绘制图形：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们可以创建不同的图形类，如 <code>Circle</code> 和 <code>Rectangle</code>，分别继承 <code>Shape</code> 类，并实现 <code>draw()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制一个圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制一个矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以创建一个 <code>Drawing</code> 类，它接收一个 <code>Shape</code> 类型的列表，并提供一个 <code>drawAll()</code> 方法来绘制所有图形：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Shape&gt; shapes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Drawing</span><span class="params">(List&lt;Shape&gt; shapes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shapes = shapes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们通过抽象类 <code>Shape</code> 将图形的绘制行为抽象出来，并通过封装将不同图形的具体实现细节隐藏起来。这样，当我们需要添加新的图形类型时（例如三角形），只需要创建一个新的类（如 <code>Triangle</code>），继承 <code>Shape</code> 并实现 <code>draw()</code> 方法。我们不需要修改 <code>Drawing</code> 类或其他现有代码。</p>
<p>这个例子展示了如何通过抽象和封装实现开闭原则，使得软件系统易于扩展和维护。</p>
]]></content>
      <tags>
        <tag>开闭原则</tag>
        <tag>面向对象设计</tag>
        <tag>抽象</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象方法与接口在概念上的异同</title>
    <url>/2023/04/16/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%9C%A8%E6%A6%82%E5%BF%B5%E4%B8%8A%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #抽象类 #抽象概念 #接口 #约束机制 #继承 #抽象方法 #父类 #子类 </p>
<hr>
<blockquote>
<p>在一定程度上，我是否可以理解为一个父类中的抽象方法就是这个父类承诺的这个类的子类们自身要实现的所有方法，如果将接口比喻成一个标签用以表示一个类承诺实现了这个标签所代表的所有方法，那么抽象方法本身也是一种形式的标签</p>
</blockquote>
<p>是的，在一定程度上，你可以这样理解。抽象方法是父类对子类的一种约束，表示子类必须实现这个方法。这种约束关系确保了在父类中定义的抽象方法在所有子类中都有具体的实现。从这个角度看，抽象方法确实可以看作是一种”标签”，它告诉子类应该实现某些行为。</p>
<p>与接口相比，抽象方法在父类中定义，而接口是一种独立的结构，可以被多个类实现。接口也可以看作是一种”标签”，表示实现了该接口的类承诺实现了接口中定义的所有方法。</p>
<p>总的来说，抽象方法和接口都是一种约束机制，用于确保实现它们的类具有某些特定的行为。抽象方法主要用于继承关系中，而接口则可以实现更灵活的多重继承效果。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
        <tag>接口</tag>
        <tag>抽象类</tag>
        <tag>抽象概念</tag>
        <tag>约束机制</tag>
        <tag>抽象方法</tag>
        <tag>父类</tag>
        <tag>子类</tag>
      </tags>
  </entry>
  <entry>
    <title>理解纯is-a关系和is-like-a关系</title>
    <url>/2023/04/16/%E7%90%86%E8%A7%A3%E7%BA%AFis-a%E5%85%B3%E7%B3%BB%E5%92%8Cis-like-a%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #继承 #is-a关系 #is-like-a关系</p>
<hr>
<p>这段文字主要在讨论两种不同的继承关系：纯 is-a 关系和 is-like-a 关系。</p>
<ol>
<li> 纯is-a关系：在这种关系中，子类只覆盖（重写）基类的方法，而不添加任何新方法。这意味着子类对象可以完美地替换基类对象，因为它们具有相同的接口。在这种情况下，多态会处理一切，你不需要知道子类的额外信息。</li>
</ol>
<p>这种方式看起来是继承的理想方式，但它并非适用于所有场景。</p>
<ol start="2">
<li> is-like-a关系：在这种关系中，子类不仅覆盖基类的方法，还扩展了基类的接口，添加了额外的方法。子类与基类具有相同的基本接口，但还具有其他特性，需要额外的方法来实现。</li>
</ol>
<p>这种方法在某些情况下也是有用的，但它有一个缺点。一旦你向上转型（upcast），你就不能调用子类中扩展的那部分接口的方法。在某些情况下，你可能需要重新发现对象的确切类型，以便访问该类型的扩展方法。</p>
<p>这段文字的目的是让你了解在设计类的继承结构时，可能会遇到这两种不同的情况。在日常开发过程中，根据问题的具体需求，你可能会遇到这两种情况。关键是理解这两种关系的优缺点，并在实际情况中做出合适的设计选择。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>is-like-a关系</tag>
        <tag>继承</tag>
        <tag>is-a关系</tag>
      </tags>
  </entry>
  <entry>
    <title>理解接口（Interface）的抽象概念</title>
    <url>/2023/04/16/%E7%90%86%E8%A7%A3%E6%8E%A5%E5%8F%A3%EF%BC%88Interface%EF%BC%89%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #接口 #面向对象 #抽象概念</p>
<hr>
<blockquote>
<p>我注意到一件事，在我们学习 onjava8这本书的时候，里面是不是的会提及接口（interface）这一概念，但是有的时候似乎并不是说的关键字 interface，而是一种抽象概念的接口—用以表达的是一个类对外开放的那些实现的方，是一种基于 java 面向对象思想而设计的一种抽象层面，即，对外提供接口而不暴露具体实现的这么一种思想，的表述？</p>
</blockquote>
<p>你的理解是正确的。在 Java 中，当我们谈论接口（interface）时，它可能有两层含义。一种是具体的关键字 <code>interface</code>，它用于创建一种特殊的类型，这种类型只包含抽象方法和静态常量。另一种含义是抽象概念上的接口，它表示一个类对外暴露的方法和属性，用于与其他类进行交互。</p>
<p>抽象概念上的接口强调了面向对象编程的一种思想：封装。封装是指将实现细节隐藏起来，仅向外界提供有限的、可控的访问途径。这样，外部代码只需要关注类的接口（即暴露的方法和属性），而不需要了解其内部实现。这使得我们可以在不影响其他代码的情况下，随时更改类的内部实现。</p>
<p>Java的关键字 <code>interface</code> 实际上也是基于这种抽象概念的接口思想设计的。通过使用关键字 <code>interface</code> 创建的接口类型，我们可以定义一组方法，表示一种规范或协议，实现该接口的类需要遵循这个规范。这样，我们就可以基于接口而非具体实现编写代码，从而提高了代码的灵活性和可扩展性。</p>
<p>总之，Java中的接口（interface）既可以表示一种具体的类型（关键字 <code>interface</code>），也可以表示一种抽象概念（类对外暴露的方法和属性）。这两种含义都是基于面向对象编程的封装思想而设计的，旨在提高代码的可维护性和可扩展性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
        <tag>抽象概念</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>编写构造器的一条良好规范</title>
    <url>/2023/04/16/%E7%BC%96%E5%86%99%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E4%B8%80%E6%9D%A1%E8%89%AF%E5%A5%BD%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>做尽量少的事让对象进入良好状态。如果有可能的话，尽量不要调用类中的任何方法。在基类的构造器中能安全调用的只有基类的 <strong>final</strong> 方法（这也适用于可被看作是 <strong>final</strong> 的 <strong>private</strong> 方法）。这些方法不能被重写，因此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。</p>
]]></content>
  </entry>
</search>
